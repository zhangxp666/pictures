# 树

- 了解树是如何用于实现几个流行的操作系统中的文件系统的。
- 了解树如何用来计算算术表达式的值。
- 指出如何利用树支持以O(ogM)平均时间进行的各种搜索操作，以及如何细化以得到最坏情况时间界O(logN。我们还将讨论当数据被存放在磁盘上时如何实现这些操作。
- 讨论并使用set和map类。

## 预备知识

根的深度是0，所有叶子的高度是0

### 树的实现

![image-20200405150137532](E:\markdownbak\image-20200405150137532.png)

```cpp
struct TreeNode
{
	Object element;
	TreeNode *firstChild;
	TreeNode *nextsibling;
};
```



### 树的遍历及应用

- 前序遍历: 对结点的处理工作是在它的诸儿子结点被处理之前进行的。
- 后序遍历： 在一个节点的工作是在它的诸儿子节点被计算后进行的。

## 二叉树

二叉树是一棵每个结点不能有多于两个儿子的树。

### 实现

```cpp
struct BinaryNode
{
    object element;// The data in the node
	BinaryNode *left;// Left child .
	BinaryNode *right;//Right chi1d
};
```



### 一个例子——表达式树

![image-20200405153620757](E:\markdownbak\image-20200405153620757.png)

后序遍历得到后缀表达式

中序遍历得到中缀表达式

## 查找树ADT——二叉查找树

使二叉树成为二叉查找树的性质是，对于树中的每个结点X,它的左子树中所有项的值小于x中的项，而它的右子树中所有项的值大于x中的项。



平均时间复杂度为$O(\log N)$,但不是完全正确的，二叉树有可能不平衡（特别是在多次删除的情况下，可能导致左子树比右子树深）。

```cpp
// BinarySearchTree class
//
// CONSTRUCTION: with ITEM_NOT_FOUND object used to signal failed finds
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// void remove( x )       --> Remove x
// bool contains( x )     --> Return true if x is present
// Comparable findMin( )  --> Return smallest item
// Comparable findMax( )  --> Return largest item
// boolean isEmpty( )     --> Return true if empty; else false
// void makeEmpty( )      --> Remove all items
// void printTree( )      --> Print tree in sorted order
// ******************ERRORS********************************
// Throws UnderflowException as warranted

template <typename Comparable>
class BinarySearchTree
{
  public:
    BinarySearchTree( ) :root( NULL )
    {
    }

    BinarySearchTree( const BinarySearchTree & rhs ) : root( NULL )
    {
        *this = rhs;
    }

    /**
	 * Destructor for the tree
	 */
    ~BinarySearchTree( )
    {
        makeEmpty( );
    }

    /**
     * Find the smallest item in the tree.
     * Throw UnderflowException if empty.
     */
    const Comparable & findMin( ) const
    {
        if( isEmpty( ) )
            throw UnderflowException( );
        return findMin( root )->element;
    }

    /**
     * Find the largest item in the tree.
     * Throw UnderflowException if empty.
     */
    const Comparable & findMax( ) const
    {
        if( isEmpty( ) )
            throw UnderflowException( );
        return findMax( root )->element;
    }

    /**
     * Returns true if x is found in the tree.
     */
    bool contains( const Comparable & x ) const
    {
        return contains( x, root );
    }

    /**
     * Test if the tree is logically empty.
     * Return true if empty, false otherwise.
     */
    bool isEmpty( ) const
    {
        return root == NULL;
    }

    /**
     * Print the tree contents in sorted order.
     */
    void printTree( ostream & out = cout ) const
    {
        if( isEmpty( ) )
            out << "Empty tree" << endl;
        else
            printTree( root, out );
    }

    /**
     * Make the tree logically empty.
     */
    void makeEmpty( )
    {
        makeEmpty( root );
    }

    /**
     * Insert x into the tree; duplicates are ignored.
     */
    void insert( const Comparable & x )
    {
        insert( x, root );
    }
     
    /**
     * Remove x from the tree. Nothing is done if x is not found.
     */
    void remove( const Comparable & x )
    {
        remove( x, root );
    }

    /**
     * Deep copy.
     */
    const BinarySearchTree & operator=( const BinarySearchTree & rhs )
    {
        if( this != &rhs )
        {
            makeEmpty( );
            root = clone( rhs.root );
        }
        return *this;
    }

  private:
    struct BinaryNode
    {
        Comparable element;
        BinaryNode *left;
        BinaryNode *right;

        BinaryNode( const Comparable & theElement, BinaryNode *lt, BinaryNode *rt )
            : element( theElement ), left( lt ), right( rt ) { }
    };

    BinaryNode *root;


    /**
     * Internal method to insert into a subtree.
     * x is the item to insert.
     * t is the node that roots the subtree.
     * Set the new root of the subtree.
     */
    void insert( const Comparable & x, BinaryNode * & t )
    {
        if( t == NULL )
            t = new BinaryNode( x, NULL, NULL );
        else if( x < t->element )
            insert( x, t->left );
        else if( t->element < x )
            insert( x, t->right );
        else
            ;  // Duplicate; do nothing
    }

    /**
     * Internal method to remove from a subtree.
     * x is the item to remove.
     * t is the node that roots the subtree.
     * Set the new root of the subtree.
     */
    void remove( const Comparable & x, BinaryNode * & t )
    {
        if( t == NULL )
            return;   // Item not found; do nothing
        if( x < t->element )
            remove( x, t->left );
        else if( t->element < x )
            remove( x, t->right );
        else if( t->left != NULL && t->right != NULL ) // Two children
        {
            t->element = findMin( t->right )->element;
            remove( t->element, t->right );
        }
        else
        {
            BinaryNode *oldNode = t;
            t = ( t->left != NULL ) ? t->left : t->right;
            delete oldNode;
        }
    }

    /**
     * Internal method to find the smallest item in a subtree t.
     * Return node containing the smallest item.
     */
    BinaryNode * findMin( BinaryNode *t ) const
    {
        if( t == NULL )
            return NULL;
        if( t->left == NULL )
            return t;
        return findMin( t->left );
    }

    /**
     * Internal method to find the largest item in a subtree t.
     * Return node containing the largest item.
     */
    BinaryNode * findMax( BinaryNode *t ) const
    {
        if( t != NULL )
            while( t->right != NULL )
                t = t->right;
        return t;
    }


    /**
     * Internal method to test if an item is in a subtree.
     * x is item to search for.
     * t is the node that roots the subtree.
     */
    bool contains( const Comparable & x, BinaryNode *t ) const
    {
        if( t == NULL )
            return false;
        else if( x < t->element )
            return contains( x, t->left );
        else if( t->element < x )
            return contains( x, t->right );
        else
            return true;    // Match
    }
/****** NONRECURSIVE VERSION*************************
    bool contains( const Comparable & x, BinaryNode *t ) const
    {
        while( t != NULL )
            if( x < t->element )
                t = t->left;
            else if( t->element < x )
                t = t->right;
            else
                return true;    // Match

        return false;   // No match
    }
*****************************************************/

    /**
     * Internal method to make subtree empty.
     */
    void makeEmpty( BinaryNode * & t )
    {
        if( t != NULL )
        {
            makeEmpty( t->left );
            makeEmpty( t->right );
            delete t;
        }
        t = NULL;
    }

    /**
     * Internal method to print a subtree rooted at t in sorted order.
     */
    void printTree( BinaryNode *t, ostream & out ) const
    {
        if( t != NULL )
        {
            printTree( t->left, out );
            out << t->element << endl;
            printTree( t->right, out );
        }
    }

    /**
     * Internal method to clone subtree.
     */
    BinaryNode * clone( BinaryNode *t ) const
    {
        if( t == NULL )
            return NULL;
        else
            return new BinaryNode( t->element, clone( t->left ), clone( t->right ) );
    }
};


```

### remove

-  当结点是树叶，可以直接删除
- 当节点有一个儿子，则该节点的父节点调整它的链以绕过该节点后，删除
- 当节点有两个儿子，则用其右子树的最小数据代替该节点的数据，并删除那个节点。

### 懒惰删除

当一个元素要被删除时，它仍留在树中，只是做了个删除的记号。

## AVL树

带有平衡条件的二叉查找树。平衡条件是每个每个节点的左子树和右子树的高度最多相差一。

除去插入以外（假设懒惰删除），所有树操作都可以以$O（\log N）$执行。

插入时，需要更新通向根节点路径上那些结点的所有平衡信息。称之为旋转。

把必须重新平衡的结点叫作a。由于任意结点最多有两个儿子，因此高度不平衡时，a点的两棵子树的高度差2。容易看出，这种不平衡可能出现在下面4种情况中:

1. 对a的左儿子的左子树进行一次插入。
2. 对a的左儿子的右子树进行一次插入。
3. 对a的右儿子的左子树进行一次插入。
4. 对a的右儿子的右子树进行一-次插入。

情形(1)和(4)是关于a点的镜像对称，而情形(2)和(3)也是关于a点的镜像对称。因此，理论上只有两种情况，当然从编程的角度来看还是四种情形。

第一种情况是插入发生在“外边”的情形( 即左一左的情况或右一右的情况)，该情况通过对树的一次单旋转(single rotation)而完成调整。

第二种情况是插入发生在“内部”的情形(即左一右的情况或右一左的情况)， 该情况通过稍微复杂些的双旋转(double rotation)来处理。

### 单旋转

​	图4-34所描述的情况只是情形(1)的一种可能的情况，在插入之前k2满足AVL性质，但在插入之后这种性质被破坏了。子树X已经“长”出一层，这使得它比子树Z深出2层。

​	为使树恢复平衡，我们把X上移一层，并把Z下移一层。在原树中k2> k1,于是在新树中k2变成了k1的右儿子，X和Z仍然分别是k1的左儿子和k2的右儿子。子树Y包含原树中介于k1和k2之间的那些结点，可以将它放在新树中k的左儿子的位置上。

​	这样的操作只需要一部分链改变， 结果我们得到另外一棵二叉查找树，它是一棵AVL树， 因为X向上移动了一层，Y停在原来的水平上，而Z下移一层。k2和k1不仅满足AVL要求，而且它们的子树都恰好处在同一高度上。不仅如此，整个树的新高度恰恰与插入前原树的高度相同，而插入操作却使得子树X长高了。**因此，通向根结点的路径的高度不需要进一步的修正，因而也不需进一步旋转**。

![image-20200406184857224](E:\markdownbak\image-20200406184857224.png)

![image-20200406191634832](E:\markdownbak\image-20200406191634832.png)

情形（4）代表了一种对称的情况。

![image-20200406191810995](E:\markdownbak\image-20200406191810995.png)

![image-20200406191922637](E:\markdownbak\image-20200406191922637.png)

### 双旋转

​	在图4-37中，子树Y已经有一项插入其中，这个事实保证它是非空的。因此，可以假设它有一个根和两棵子树。于是，可以把整棵树看成是四棵子树由3个结点连接。如图所示，恰好树B或树C中有一棵比D深两层(除非它们都是空的)

​	为了重新平衡，我们看到，不能再让k1作为根了，唯一的选择就是把k2作为新的根。这迫使k1是k2的左儿子，k3是它的右儿子，从而完全确定了这4棵树的最终位置。容易看出，最后得到的树满足AVL树的性质，与单旋转的情形一样，我们也把树的高度恢复到插入以前的水平，这可保证所有的重新平衡和高度更新是完善的。

​	其效果与先在k1和k2之间旋转而后再在k3和它的新儿子k2之间旋转的效果是相同的。


![image-20200406205215199](E:\markdownbak\image-20200406205215199.png)

图4-39指出，对称情形(3)也可以通过双旋转得以修正。

![image-20200406205637554](E:\markdownbak\image-20200406205637554.png)

![image-20200406210941168](E:\markdownbak\image-20200406210941168.png)

![image-20200406211128192](E:\markdownbak\image-20200406211128192.png)

### 编程实现

```cpp
// AvlTree class
//
// CONSTRUCTION: with ITEM_NOT_FOUND object used to signal failed finds
//
// ******************PUBLIC OPERATIONS*********************
// void insert( x )       --> Insert x
// void remove( x )       --> Remove x (unimplemented)
// bool contains( x )     --> Return true if x is present
// Comparable findMin( )  --> Return smallest item
// Comparable findMax( )  --> Return largest item
// boolean isEmpty( )     --> Return true if empty; else false
// void makeEmpty( )      --> Remove all items
// void printTree( )      --> Print tree in sorted order
// ******************ERRORS********************************
// Throws UnderflowException as warranted

template <typename Comparable>
class AvlTree
{
  public:
    AvlTree( ) : root( NULL )
      { }
    AvlTree( const AvlTree & rhs ) : root( NULL )
    {
        *this = rhs;
    }

    ~AvlTree( )
    {
        makeEmpty( );
    }

    /**
     * Find the smallest item in the tree.
     * Throw UnderflowException if empty.
     */
    const Comparable & findMin( ) const
    {
        if( isEmpty( ) )
            throw UnderflowException( );
        return findMin( root )->element;
    }

    /**
     * Find the largest item in the tree.
     * Throw UnderflowException if empty.
     */
    const Comparable & findMax( ) const
    {
        if( isEmpty( ) )
            throw UnderflowException( );
        return findMax( root )->element;
    }

    /**
     * Returns true if x is found in the tree.
     */
    bool contains( const Comparable & x ) const
    {
        return contains( x, root );
    }

    /**
     * Test if the tree is logically empty.
     * Return true if empty, false otherwise.
     */
    bool isEmpty( ) const
    {
        return root == NULL;
    }

    /**
     * Print the tree contents in sorted order.
     */
    void printTree( ) const
    {
        if( isEmpty( ) )
            cout << "Empty tree" << endl;
        else
            printTree( root );
    }

    /**
     * Make the tree logically empty.
     */
    void makeEmpty( )
    {
        makeEmpty( root );
    }

    /**
     * Insert x into the tree; duplicates are ignored.
     */
    void insert( const Comparable & x )
    {
        insert( x, root );
    }
     
    /**
     * Remove x from the tree. Nothing is done if x is not found.
     */
    void remove( const Comparable & x )
    {
        cout << "Sorry, remove unimplemented; " << x <<
                " still present" << endl;
    }

    /**
     * Deep copy.
     */
    const AvlTree & operator=( const AvlTree & rhs )
    {
        if( this != &rhs )
        {
            makeEmpty( );
            root = clone( rhs.root );
        }
        return *this;
    }

  private:
    struct AvlNode
    {
        Comparable element;
        AvlNode   *left;
        AvlNode   *right;
        int       height;

        AvlNode( const Comparable & theElement, AvlNode *lt,
                                                AvlNode *rt, int h = 0 )
          : element( theElement ), left( lt ), right( rt ), height( h ) { }
    };

    AvlNode *root;


    /**
     * Internal method to insert into a subtree.
     * x is the item to insert.
     * t is the node that roots the subtree.
     * Set the new root of the subtree.
     */
    void insert( const Comparable & x, AvlNode * & t )
    {
        if( t == NULL )
            t = new AvlNode( x, NULL, NULL );
        else if( x < t->element )
        {
            insert( x, t->left );
            if( height( t->left ) - height( t->right ) == 2 )
                if( x < t->left->element )
                    rotateWithLeftChild( t );
                else
                    doubleWithLeftChild( t );
        }
        else if( t->element < x )
        {
            insert( x, t->right );
            if( height( t->right ) - height( t->left ) == 2 )
                if( t->right->element < x )
                    rotateWithRightChild( t );
                else
                    doubleWithRightChild( t );
        }
        else
            ;  // Duplicate; do nothing
        t->height = max( height( t->left ), height( t->right ) ) + 1;
    }

    /**
     * Internal method to find the smallest item in a subtree t.
     * Return node containing the smallest item.
     */
    AvlNode * findMin( AvlNode *t ) const
    {
        if( t == NULL )
            return NULL;
        if( t->left == NULL )
            return t;
        return findMin( t->left );
    }

    /**
     * Internal method to find the largest item in a subtree t.
     * Return node containing the largest item.
     */
    AvlNode * findMax( AvlNode *t ) const
    {
        if( t != NULL )
            while( t->right != NULL )
                t = t->right;
        return t;
    }


    /**
     * Internal method to test if an item is in a subtree.
     * x is item to search for.
     * t is the node that roots the tree.
     */
    bool contains( const Comparable & x, AvlNode *t ) const
    {
        if( t == NULL )
            return false;
        else if( x < t->element )
            return contains( x, t->left );
        else if( t->element < x )
            return contains( x, t->right );
        else
            return true;    // Match
    }
/****** NONRECURSIVE VERSION*************************
    bool contains( const Comparable & x, AvlNode *t ) const
    {
        while( t != NULL )
            if( x < t->element )
                t = t->left;
            else if( t->element < x )
                t = t->right;
            else
                return true;    // Match

        return false;   // No match
    }
*****************************************************/

    /**
     * Internal method to make subtree empty.
     */
    void makeEmpty( AvlNode * & t )
    {
        if( t != NULL )
        {
            makeEmpty( t->left );
            makeEmpty( t->right );
            delete t;
        }
        t = NULL;
    }

    /**
     * Internal method to print a subtree rooted at t in sorted order.
     */
    void printTree( AvlNode *t ) const
    {
        if( t != NULL )
        {
            printTree( t->left );
            cout << t->element << endl;
            printTree( t->right );
        }
    }

    /**
     * Internal method to clone subtree.
     */
    AvlNode * clone( AvlNode *t ) const
    {
        if( t == NULL )
            return NULL;
        else
            return new AvlNode( t->element, clone( t->left ), clone( t->right ), t->height );
    }
        // Avl manipulations
    /**
     * Return the height of node t or -1 if NULL.
     */
    int height( AvlNode *t ) const
    {
        return t == NULL ? -1 : t->height;
    }

    int max( int lhs, int rhs ) const
    {
        return lhs > rhs ? lhs : rhs;
    }

    /**
     * Rotate binary tree node with left child.
     * For AVL trees, this is a single rotation for case 1.
     * Update heights, then set new root.
     */
    void rotateWithLeftChild( AvlNode * & k2 )
    {
        AvlNode *k1 = k2->left;
        k2->left = k1->right;
        k1->right = k2;
        k2->height = max( height( k2->left ), height( k2->right ) ) + 1;
        k1->height = max( height( k1->left ), k2->height ) + 1;
        k2 = k1;
    }

    /**
     * Rotate binary tree node with right child.
     * For AVL trees, this is a single rotation for case 4.
     * Update heights, then set new root.
     */
    void rotateWithRightChild( AvlNode * & k1 )
    {
        AvlNode *k2 = k1->right;
        k1->right = k2->left;
        k2->left = k1;
        k1->height = max( height( k1->left ), height( k1->right ) ) + 1;
        k2->height = max( height( k2->right ), k1->height ) + 1;
        k1 = k2;
    }

    /**
     * Double rotate binary tree node: first left child.
     * with its right child; then node k3 with new left child.
     * For AVL trees, this is a double rotation for case 2.
     * Update heights, then set new root.
     */
    void doubleWithLeftChild( AvlNode * & k3 )
    {
        rotateWithRightChild( k3->left );
        rotateWithLeftChild( k3 );
    }

    /**
     * Double rotate binary tree node: first right child.
     * with its left child; then node k1 with new right child.
     * For AVL trees, this is a double rotation for case 3.
     * Update heights, then set new root.
     */
    void doubleWithRightChild( AvlNode * & k1 )
    {
        rotateWithLeftChild( k1->right );
        rotateWithRightChild( k1 );
    }
};
```

## 伸展树

保证从空树开始的任意连续M次对数的操作最多花费$O(M\log N)$时间。这种保证不排除单词花费$O(N)$,但不存在不好的输入序列。每次操作的摊还时间时$O(\log N)$。



伸展树的基本想法是，当一个结点被访问后，它就要经过一系列的AVL树旋转被推到根上。

### 伸展

从底向上沿着访问路径旋转。令X是在访问路径上的一个(非根)结点，我们将在这个路径上实施旋转操作。

- 如果X的父结点是树根，那么只要旋转X和树根。这就是沿着访问路径上的最后的旋转。

- 否则，X就有父亲(P)和祖父(G)，存在两种情况以及对称的情形要考虑。
  - 第一种情况是之字形(zig-zag) 情形(见图4-47)。 这里，X是右儿子，P是左儿子(反之亦然)。如果是这种情况，那么我们执行一次就像AVL双旋转那样的双旋转。
  - 否则，出现另一种一字形(zig-zig) 情形: X和P或者都是左儿子，或者都是右儿子。在这种情况下，我们把图4-48左边的树变换成右边的树。

![image-20200406215053938](E:\markdownbak\image-20200406215053938.png)

一个例子：

![image-20200406215254458](E:\markdownbak\image-20200406215254458.png)

![image-20200406215304920](E:\markdownbak\image-20200406215304920.png)

![image-20200406215313278](E:\markdownbak\image-20200406215313278.png)

伸展操作不仅将访问的结点移动到根处，而且还有把访问路径上的大部分结点的深度大致减少一半的效果 (某些浅的结点最多向下推两个层次)。

## 树的遍历

-  中序遍历：先处理左子树，然后是当前结点，最后处理右子树
- 后续遍历：先处理左子树，然后是右子树，最后是当前结点
- 前序遍历：前处理当前结点，然后是左子树，最后右子树
- 层序遍历：所有深度为d的结点要在d+1的结点之前处理

## B树

阶为M的B树是一棵具有下面结构特性的树:

- 数据项存储在树叶上
- 非叶结点存储直到M-1个键，以指示搜索的方向，键i代表i+1中的最小的键
- 树的根或是一片树叶，或是其儿子数在2和M之间
- 除根外，所有非树叶结点的儿子数在[ M/2] 和M之间
- 所有的树叶都在相同的深度上并有「L/2]和L之间个数据项，L由具体磁盘大小情况确定。.

![image-20200406221447060](E:\markdownbak\image-20200406221447060.png)

#### 插入

图4-63显示了一个问题: 55想要插入其中的那片树叶已经满了。不过解法却不复杂:由于现在有L + 1项，因此把它们
分成两片树叶，这两片树叶保证都有所需要的记录的最小个数。我们形成两片树叶，每叶3项。

![image-20200406222216978](E:\markdownbak\image-20200406222216978.png)

当一个非树叶结点分裂时，它的父结点得到了一个儿子。如果父结点的儿了个数已经达到规定的限度，继续沿树向上分裂结点直到找到一个父结点它不需要再分裂，或者到达树根。不能分裂树根，但可以建立一个新的根，这个根以分裂得到的两个树根作为它的两个儿子。这就是准许树根可以最少有两个儿子的特权的原因。

![image-20200406222345978](E:\markdownbak\image-20200406222345978.png)

## 标准库中的set和map

### set

- iterator
- begin
- end
- size
- empty
- insert   //返回pair<iterator, bool>
- erase
- find

### map

- begin
- end
- size
- empty
- iterator  //pair<KeyType , ValueType> 
- find
- []

### set和map的实现

典型的用法是自顶向下的红黑树。

